<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Network &#8211; M43L57R0M</title>
	<atom:link href="./index.html" rel="self" type="application/rss+xml" />
	<link>./../../../index.html</link>
	<description>Information Security, Software Engineering</description>
	<lastBuildDate>Sat, 18 Sep 2021 17:11:38 +0000</lastBuildDate>
	<language>en-GB</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Snort IDS Custom Dynamic Preprocessor, Part 1</title>
		<link>./../../../snort-custom-dynamic-preprocessor/index.html</link>
		
		<dc:creator><![CDATA[spen440]]></dc:creator>
		<pubDate>Tue, 08 Aug 2017 10:49:43 +0000</pubDate>
				<category><![CDATA[IDS]]></category>
		<category><![CDATA[Network Reconnaissance]]></category>
		<category><![CDATA[SIEM]]></category>
		<category><![CDATA[Network]]></category>
		<category><![CDATA[Plugin]]></category>
		<category><![CDATA[Snort]]></category>
		<category><![CDATA[Splunk]]></category>
		<guid isPermaLink="false">./../../../index.html?p=245</guid>

					<description><![CDATA[&#160; Introduction This post describes process of building a custom dynamic preprocessor plugin for the Snort Network Intrusion Detection / Prevention System (IDS / IPS). Snort is rules-based IDS. Although Snort rules have a simple structure, the number and variety of options within the Snort rule syntax allows reasonably complex analysis of packets under inspection [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>&nbsp;</p>
<h2>Introduction</h2>
<p>This post describes process of building a custom dynamic preprocessor plugin for the Snort Network Intrusion Detection / Prevention System (IDS / IPS).</p>
<p>Snort is rules-based IDS. Although Snort rules have a simple structure, the number and variety of options within the Snort rule syntax allows reasonably complex analysis of packets under inspection to be performed. This is fine for situations where the symptoms of the threat being defended against can be <span id="more-245"></span></p>
<p>encapsulated within single logical expression (for example: &#8220;if the packet under inspection uses the TCP protocol, comes from the external network, is directed towards a database server within the internal network, and has the characters &#8220;0x02&#8243; at an offset of 23 bytes within its payload, then drop the packet&#8221;). However, if more complex analysis is needed then a different approach is required.</p>
<h2>Preprocessors</h2>
<p>A Snort preprocessor is a type of plugin which can be used to contribute additional processing functional to the core engine. Dynamic preprocessors are self contained libraries written in C which can be compiled independently of the main code base. The library is then included by placing it in a directory where Snort can find it at start-up, and updating the Snort configuration file so that Snort is aware of it.</p>
<h2>Shellcode Detection</h2>
<p>In a <a href="./../../../win7-seh-buffer-overflow-exploit/index.html">previous post</a>, I demonstrated a technique for exploiting a known vulnerability within a commercially available chat server application. The exploit involves delivering a payload containing reverse TCP shellcode which is then used to gain control over the compromised host.</p>
<p>The ultimate aim of this exercise is to develop a dynamic preprocessor which will be capable of detecting the pattern of data within a packet payload which indicates that a buffer overflow attack is in progress. I plan to do this in two parts:</p>
<p>The first part (this post) will describe the end-to-end process of putting together a template for the preprocessor, building it, checking that it gets loaded by Snort at runtime and then verifying that we can cause it to generate alerts by sending malicious traffic across the network segment it is monitoring, and checking that these alerts are then fowarded to an SIEM for analysis.</p>
<p>The second part (yet to be written at this point in time) will focus on the implementation detail of the main processing function within the preprocessor. The aim is devise an algorithm which can detect the tell-tale signs of a buffer overflow attack, without relying rigidly on the details of any specific vulnerability or known attack strategy. By understanding the general anatomy of a buffer overflow attack, I hope it will be possible to make informed judgements about the meaning of data values within the payload by looking at them within the context of the whole payload, rather than just determing their absence or presence, as a rule does.  The approach taken by Stig Andersson, Andrew Clark, and George Mohay in their research paper &#8220;<a href="https://www.researchgate.net/publication/27478341_Network_based_buffer_overflow_detection_by_exploit_code_analysis">Network based buffer overflow detection by exploit code analysis</a>&#8221; looks interesting and may provide some useful ideas.</p>
<p>It&#8217;s quite possible to achieve the functionality I&#8217;ve implemented here in Part 1 just using a rule; the reason I&#8217;ve split the development into two parts is partly because I&#8217;m doing this over a period of a few weeks and I&#8217;m using this blog as a kind of incremental work journal, and partly because I think this structure might of more use to people who just want to know how to get a template dynamic preprocessor project up and running but have some other purpose in mind for it.</p>
<h2>Test Lab</h2>
<p>The test lab was put together with the help of <a href="https://twitter.com/da_667">Tony Robinson&#8217;s</a> excellent book &#8220;<a href="https://www.goodreads.com/book/show/35406833-building-virtual-machine-labs">Building Virtual Machine Labs: A Hands-On Guide</a>&#8220;. The network architecture is divided into a number of segments using the virtual networking facilities provided by VirtualBox&#8217;s VMs.  This allows the guest VMs to be segregated logically according to their respective functions within the test lab. This approach enforces security by filtering traffic through a VM which acts as a firewall and a network gateway (pfSense). In this manner, traffic between the virtual and local physical networks, and traffic between the IPS (Snort) VM and the SIEM (Splunk) VM and the Snort management interface host, can be monitored and controlled separately.</p>
<p>In this setup, Snort is configured to be in-line between two network segments using a pair of virtual network adapters, rather than simply monitoring traffic passively. As well as allowing Snort to act as an IPS (ie by dropping packets) if required, a major advantage of this arrangement is that it allows one segment of the lab to be configured as a secure sandbox for examining malware if required. Shutting down the IPS VM will effectively isolate the segment containing the compromised host, which is a very useful &#8220;panic button&#8221; facility to have available, should things get out of control.</p>
<figure id="attachment_297" aria-describedby="caption-attachment-297" style="width: 980px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2.png"><img fetchpriority="high" decoding="async" class="wp-image-297 size-large" src="./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2-1024x704.png" alt="" width="980" height="674" data-wp-pid="297" srcset="./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2-1024x704.png 1024w, ./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2-300x206.png 300w, ./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2-768x528.png 768w, ./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2-210x144.png 210w, ./../../../wp-content/uploads/2017/08/pwnlab-nw-diag-2.png 1076w" sizes="(max-width: 980px) 100vw, 980px" /></a><figcaption id="caption-attachment-297" class="wp-caption-text">Virtualised Lab Architecture</figcaption></figure>
<p>&nbsp;</p>
<figure id="attachment_263" aria-describedby="caption-attachment-263" style="width: 980px" class="wp-caption alignnone"><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54.png"><img decoding="async" class="wp-image-263 size-large" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54-1024x576.png" alt="" width="980" height="551" data-wp-pid="263" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54-1024x576.png 1024w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54-300x169.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54-768x432.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54-210x118.png 210w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-54.png 1366w" sizes="(max-width: 980px) 100vw, 980px" /></a><figcaption id="caption-attachment-263" class="wp-caption-text">Virtualised Test Lab &#8211; VirtualBox on CentOS 7</figcaption></figure>
<h2>DPX</h2>
<p>The nice people over at <a href="https://www.snort.org/">Snort headquarters</a> have made a example dynamic preprocessor  (<span style="text-decoration: underline;">D</span>ymanic <span style="text-decoration: underline;">P</span>reprocessor e<span style="text-decoration: underline;">X</span>ample) project available for <a href="https://www.snort.org/documents/38">download</a>. The project provides the source code for an &#8220;empty&#8221; plugin, build scripts which take care of bringing all the required elements together and distributing the ouput binaries to the correct locations, plus a unit test script (bundled with some test data in the form of a .pcap file) to verify that the resultant plugin behaves as it should &#8211; in isolation, at least.</p>
<p>Although this project is really helpful in providing a head-start, the business of getting the plugin configured, registered with and loaded by Snort at start-up and called during execution takes a little more work, and not all of the steps involved are entirely intuitive.  The remainder of this post explains how to get the preprocessor up and running in a test lab environment.</p>
<h2>Installation</h2>
<p>The steps involved in downloading, installing and building the example project as-is are listed <a href="https://www.snort.org/documents/38">here</a>. Note that the source development header files for Snort itself are also needed to allow the project to be built. These won&#8217;t be present in an existing Snort installation unless it was built from source and so need will need to be downloaded separately.</p>
<figure id="attachment_275" aria-describedby="caption-attachment-275" style="width: 810px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/build-log-2.png"><img decoding="async" class="wp-image-275 size-full" src="./../../../wp-content/uploads/2017/08/build-log-2.png" alt="" width="810" height="744" data-wp-pid="275" srcset="./../../../wp-content/uploads/2017/08/build-log-2.png 810w, ./../../../wp-content/uploads/2017/08/build-log-2-300x276.png 300w, ./../../../wp-content/uploads/2017/08/build-log-2-768x705.png 768w, ./../../../wp-content/uploads/2017/08/build-log-2-210x193.png 210w" sizes="(max-width: 810px) 100vw, 810px" /></a><figcaption id="caption-attachment-275" class="wp-caption-text">Building the example dynamic preprocessor.</figcaption></figure>
<h2>Hello World</h2>
<p>As I mentioned previously, the aim in Part 1 of this post is just to add some simple functionality to the preprocessor and prove that it&#8217;s working, before moving on to more complex packet payload analysis functionality in Part 2. The following paragraphs describe what I did to acheive that objective.</p>
<h3>Source Code Changes</h3>
<p>Out of the box, the example preprocessor examines packets to determine whether the source or destination port number matches a pre-defined number. This number is defined in Snort configuration file, which needs to be modified to incude configuration values for the new preprocessor. I modified the source to allow the preprocessor to look for the presence of a sequence of hex values within the packet payload. This sequence represents the opcodes &#8220;JMP 06 NOP NOP&#8221; typically seen when an <a href="./../../../win7-seh-buffer-overflow-exploit/index.html">exploit which abuses Windows SEH</a> is deployed.</p>
<p><strong>/opt/snort_dpx/dpx-1.7/dpx.c</strong></p>
<figure id="attachment_251" aria-describedby="caption-attachment-251" style="width: 845px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/dpx-c.png"><img loading="lazy" decoding="async" class="wp-image-251 size-full" src="./../../../wp-content/uploads/2017/08/dpx-c.png" alt="" width="845" height="335" data-wp-pid="251" srcset="./../../../wp-content/uploads/2017/08/dpx-c.png 845w, ./../../../wp-content/uploads/2017/08/dpx-c-300x119.png 300w, ./../../../wp-content/uploads/2017/08/dpx-c-768x304.png 768w, ./../../../wp-content/uploads/2017/08/dpx-c-210x83.png 210w" sizes="(max-width: 845px) 100vw, 845px" /></a><figcaption id="caption-attachment-251" class="wp-caption-text">Addition of search string containing opcode hex values.</figcaption></figure>
<p><strong>/opt/snort_dpx/dpx-1.7/dpx.c</strong></p>
<figure id="attachment_250" aria-describedby="caption-attachment-250" style="width: 856px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/dpx-c-2.png"><img loading="lazy" decoding="async" class="wp-image-250 size-full" src="./../../../wp-content/uploads/2017/08/dpx-c-2.png" alt="" width="856" height="635" data-wp-pid="250" srcset="./../../../wp-content/uploads/2017/08/dpx-c-2.png 856w, ./../../../wp-content/uploads/2017/08/dpx-c-2-300x223.png 300w, ./../../../wp-content/uploads/2017/08/dpx-c-2-768x570.png 768w, ./../../../wp-content/uploads/2017/08/dpx-c-2-210x156.png 210w" sizes="(max-width: 856px) 100vw, 856px" /></a><figcaption id="caption-attachment-250" class="wp-caption-text">Addition of a simple substring search to main preprocessor method.</figcaption></figure>
<p>Notice the call to DynamicPreprocessorData.alertAdd(&#8230;), which causes an alert to be generated when the required conditions are met. This method takes seven parameters: the ID of the preprocessor, the ID of the rule, the rule revision number, the alert classication number, the alert pritority, a message string and a reference to metadata pertinent to the alert (none in this case). NB: The use of term &#8220;rule&#8221; is used here even though we&#8217;re not dealing with a rule object; I suspect this is because alerts are <em>normally</em> generated by Snort rules, and the terminolgy used within the source probably isn&#8217;t generic enough to deal with alerts generated from other sources.</p>
<h3>Configuration Changes</h3>
<p>The alert classification number used in the above method call is derived from the alert classification file which maps classfication types to alert messages:</p>
<p><strong>/opt/snort/etc/classification.conf</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/classification-config.png"><img loading="lazy" decoding="async" class="alignnone size-medium_large wp-image-249" src="./../../../wp-content/uploads/2017/08/classification-config-768x186.png" alt="" width="768" height="186" data-wp-pid="249" srcset="./../../../wp-content/uploads/2017/08/classification-config-768x186.png 768w, ./../../../wp-content/uploads/2017/08/classification-config-300x73.png 300w, ./../../../wp-content/uploads/2017/08/classification-config-210x51.png 210w, ./../../../wp-content/uploads/2017/08/classification-config.png 938w" sizes="(max-width: 768px) 100vw, 768px" /></a></p>
<p><strong>/opt/snort_dpx/dpx-1.7/dpx.c</strong></p>
<figure id="attachment_271" aria-describedby="caption-attachment-271" style="width: 845px" class="wp-caption alignnone"><a href="./../../../wp-content/uploads/2017/08/dpx-c-3.png"><img loading="lazy" decoding="async" class="wp-image-271 size-full" src="./../../../wp-content/uploads/2017/08/dpx-c-3.png" alt="" width="845" height="335" data-wp-pid="271" srcset="./../../../wp-content/uploads/2017/08/dpx-c-3.png 845w, ./../../../wp-content/uploads/2017/08/dpx-c-3-300x119.png 300w, ./../../../wp-content/uploads/2017/08/dpx-c-3-768x304.png 768w, ./../../../wp-content/uploads/2017/08/dpx-c-3-210x83.png 210w" sizes="(max-width: 845px) 100vw, 845px" /></a><figcaption id="caption-attachment-271" class="wp-caption-text">GID and SID definitions</figcaption></figure>
<p>Constants defined in the preprocessor info header file sf_preproc_info.h determine the major and and minor version numbers, plus the name of the preprocessor (the name string value is important, as it is used to identify configuration values with the snort.conf config file):</p>
<p><strong>/opt/snort_dpx/dpx-1.7/sf_preproc_info.h</strong></p>
<figure id="attachment_270" aria-describedby="caption-attachment-270" style="width: 537px" class="wp-caption alignnone"><a href="./../../../wp-content/uploads/2017/08/sf_preproc_info-2.png"><img loading="lazy" decoding="async" class="wp-image-270" src="./../../../wp-content/uploads/2017/08/sf_preproc_info-2.png" alt="" width="537" height="179" data-wp-pid="270" srcset="./../../../wp-content/uploads/2017/08/sf_preproc_info-2.png 660w, ./../../../wp-content/uploads/2017/08/sf_preproc_info-2-300x100.png 300w, ./../../../wp-content/uploads/2017/08/sf_preproc_info-2-210x70.png 210w" sizes="(max-width: 537px) 100vw, 537px" /></a><figcaption id="caption-attachment-270" class="wp-caption-text">Major/minor version numbers and preprocessor name definitions</figcaption></figure>
<p>Snort determines where to look for dynamic prepreocessors according to an entry in the snort.conf configuration file:</p>
<p><strong>/opt/snort/etc/snort.conf</strong></p>
<figure id="attachment_305" aria-describedby="caption-attachment-305" style="width: 980px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/snort-conf-1.png"><img loading="lazy" decoding="async" class="wp-image-305 size-large" src="./../../../wp-content/uploads/2017/08/snort-conf-1-1024x329.png" alt="" width="980" height="315" data-wp-pid="305" srcset="./../../../wp-content/uploads/2017/08/snort-conf-1-1024x329.png 1024w, ./../../../wp-content/uploads/2017/08/snort-conf-1-300x97.png 300w, ./../../../wp-content/uploads/2017/08/snort-conf-1-768x247.png 768w, ./../../../wp-content/uploads/2017/08/snort-conf-1-210x68.png 210w, ./../../../wp-content/uploads/2017/08/snort-conf-1.png 1147w" sizes="(max-width: 980px) 100vw, 980px" /></a><figcaption id="caption-attachment-305" class="wp-caption-text">&#8220;dynamicpreprocessor directory&#8221; entry in snort.conf</figcaption></figure>
<p>To ensure that the new preprocessor is loaded dynamically by Snort, either copy or symlink the libraries to the location specified in &#8220;dynamicpreprocessor directory&#8221; entry in the snort.conf configuration file:</p>
<figure id="attachment_262" aria-describedby="caption-attachment-262" style="width: 802px" class="wp-caption alignright"><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37.png"><img loading="lazy" decoding="async" class="wp-image-262 size-full" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37.png" alt="" width="802" height="167" data-wp-pid="262" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37.png 802w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37-300x62.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37-768x160.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-30-37-210x44.png 210w" sizes="(max-width: 802px) 100vw, 802px" /></a><figcaption id="caption-attachment-262" class="wp-caption-text">Libraries associated with the example dynamic preprocessor</figcaption></figure>
<p>Newer versions of Snort allows rules and events associated with preprocessors to be enabled and disabled individually via separate configuration file, however for the purposes of this exercise, we can just direct Snort to automatically enable all preprocessor rules with the following entry in the snort.conf configuration file:</p>
<p><strong>/opt/snort/etc/snort.conf</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/snort-conf-2.png"><img loading="lazy" decoding="async" class="size-large wp-image-306 aligncenter" src="./../../../wp-content/uploads/2017/08/snort-conf-2-1024x329.png" alt="" width="980" height="315" data-wp-pid="306" srcset="./../../../wp-content/uploads/2017/08/snort-conf-2-1024x329.png 1024w, ./../../../wp-content/uploads/2017/08/snort-conf-2-300x97.png 300w, ./../../../wp-content/uploads/2017/08/snort-conf-2-768x247.png 768w, ./../../../wp-content/uploads/2017/08/snort-conf-2-210x68.png 210w, ./../../../wp-content/uploads/2017/08/snort-conf-2.png 1147w" sizes="(max-width: 980px) 100vw, 980px" /></a></p>
<p>While we&#8217;re modifying snort.conf, let&#8217;s add an entry to configure the preprocessor&#8217;s behaviour at runtime. The following line defines the value a port number; the packet being processed must have either a source or destination port value which matches this value or the packet will be ignored by the preprocessor:</p>
<p><strong>/opt/snort/etc/snort.conf</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42.png"><img loading="lazy" decoding="async" class="alignnone size-medium_large wp-image-255" src="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42-768x241.png" alt="" width="768" height="241" data-wp-pid="255" srcset="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42-768x241.png 768w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42-300x94.png 300w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42-1024x321.png 1024w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42-210x66.png 210w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.40.42.png 1083w" sizes="(max-width: 768px) 100vw, 768px" /></a></p>
<p>To make debugging a little easier, let&#8217;s also ensure that Snort generates a vebose human-readable alert text file, as well as the standard unified binary format alert file:</p>
<p><a href="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14.png"><img loading="lazy" decoding="async" class="alignnone size-medium_large wp-image-256" src="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14-768x252.png" alt="" width="768" height="252" data-wp-pid="256" srcset="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14-768x252.png 768w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14-300x99.png 300w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14-210x69.png 210w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.42.14.png 810w" sizes="(max-width: 768px) 100vw, 768px" /></a></p>
<p>The last step is to map the preprocessor GID and SID values to human-readable message strings which will be included in the generated alerts &#8211; this is achieved by adding entries to the gen-msg.map file:</p>
<p><strong>/opt/snort/etc/gen-msg.map</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/gen-msg-map.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-252" src="./../../../wp-content/uploads/2017/08/gen-msg-map.png" alt="" width="949" height="166" data-wp-pid="252" srcset="./../../../wp-content/uploads/2017/08/gen-msg-map.png 949w, ./../../../wp-content/uploads/2017/08/gen-msg-map-300x52.png 300w, ./../../../wp-content/uploads/2017/08/gen-msg-map-768x134.png 768w, ./../../../wp-content/uploads/2017/08/gen-msg-map-210x37.png 210w" sizes="(max-width: 949px) 100vw, 949px" /></a></p>
<h2>Testing</h2>
<p>Having made the required source code and config file changes, we can now rebuild the preprocessor and then restart Snort:</p>
<p><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59.png"><img loading="lazy" decoding="async" class="alignnone size-medium_large wp-image-261" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59-768x173.png" alt="" width="768" height="173" data-wp-pid="261" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59-768x173.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59-300x68.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59-210x47.png 210w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-25-59.png 797w" sizes="(max-width: 768px) 100vw, 768px" /></a></p>
<p>Examining the syslog log file, we can see that Snort appears to have loaded without errors:</p>
<p><strong>/var/log/syslog</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/syslog-1.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-281" src="./../../../wp-content/uploads/2017/08/syslog-1.png" alt="" width="825" height="309" data-wp-pid="281" srcset="./../../../wp-content/uploads/2017/08/syslog-1.png 825w, ./../../../wp-content/uploads/2017/08/syslog-1-300x112.png 300w, ./../../../wp-content/uploads/2017/08/syslog-1-768x288.png 768w, ./../../../wp-content/uploads/2017/08/syslog-1-210x79.png 210w" sizes="(max-width: 825px) 100vw, 825px" /></a></p>
<p>&#8230;and has loaded the new dynamic preprocessor:</p>
<p><a href="./../../../wp-content/uploads/2017/08/syslog-2-2.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-283" src="./../../../wp-content/uploads/2017/08/syslog-2-2.png" alt="" width="850" height="342" data-wp-pid="283" srcset="./../../../wp-content/uploads/2017/08/syslog-2-2.png 850w, ./../../../wp-content/uploads/2017/08/syslog-2-2-300x121.png 300w, ./../../../wp-content/uploads/2017/08/syslog-2-2-768x309.png 768w, ./../../../wp-content/uploads/2017/08/syslog-2-2-210x84.png 210w" sizes="(max-width: 850px) 100vw, 850px" /></a></p>
<h3>Exploit</h3>
<p>To test the functionality of the preprocessor, we launch an attack against the target host whose payload contains the shellcode for a Windows SEH exploit:</p>
<h2><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-285" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44.png" alt="" width="850" height="360" data-wp-pid="285" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44.png 850w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44-300x127.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44-768x325.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-08-13-45-44-210x89.png 210w" sizes="(max-width: 850px) 100vw, 850px" /></a></h2>
<h3>Detection and Alerting</h3>
<p>By examining the Snort alert log file, we can see that the preprocessor has detected the SEH exploit opcode hex values and has generated an alert:</p>
<p><strong>/var/log/snort/sjd_alert.full</strong></p>
<p><a href="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26.png"><img loading="lazy" decoding="async" class="alignnone size-medium_large wp-image-258" src="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26-768x289.png" alt="" width="768" height="289" data-wp-pid="258" srcset="./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26-768x289.png 768w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26-300x113.png 300w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26-210x79.png 210w, ./../../../wp-content/uploads/2017/08/Item-0-SnappyApp-Today-at-19.47.26.png 956w" sizes="(max-width: 768px) 100vw, 768px" /></a></p>
<h3>SIEM</h3>
<p>The last step in the verifcation process is to check that the Splunk universal forwarder correctly parses the alert and forwards the details as JSON formatted data to the Splunk SIEM for analysis. By issuing a simple search for the string &#8220;DPX&#8221; in the Splunk reporting interface, we can see that the alert has been received by the SIEM:</p>
<figure id="attachment_260" aria-describedby="caption-attachment-260" style="width: 768px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58.png"><img loading="lazy" decoding="async" class="wp-image-260 size-medium_large" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58-768x432.png" alt="" width="768" height="432" data-wp-pid="260" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58-768x432.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58-300x169.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58-1024x576.png 1024w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58-210x118.png 210w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-20-58.png 1366w" sizes="(max-width: 768px) 100vw, 768px" /></a><figcaption id="caption-attachment-260" class="wp-caption-text">Preprocessor alert ingested by Splunk SIEM</figcaption></figure>
<p>Expanding the alert JSON data shows that the alert contains the data we expect in each field:</p>
<figure id="attachment_259" aria-describedby="caption-attachment-259" style="width: 768px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30.png"><img loading="lazy" decoding="async" class="wp-image-259 size-medium_large" src="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30-768x432.png" alt="" width="768" height="432" data-wp-pid="259" srcset="./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30-768x432.png 768w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30-300x169.png 300w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30-1024x576.png 1024w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30-210x118.png 210w, ./../../../wp-content/uploads/2017/08/Screenshot-from-2017-08-07-18-17-30.png 1366w" sizes="(max-width: 768px) 100vw, 768px" /></a><figcaption id="caption-attachment-259" class="wp-caption-text">Splunk SIEM displaying preprocessor alert detail</figcaption></figure>
<h2>Conclusions</h2>
<p>Getting the example dynamic preprocessor example up and running took quite a bit of detective work and trial and error, but given the amount of extra processing scope and flexibility that preprocessors provide, over and above that provided by rules alone, I believe the investment in time and effort will prove to be worthwhile.</p>
<p>Hopefully the information presented here will be of help to anyone in a similar position. It&#8217;s worth noting that the post archives over at <a href="http://seclists.org/snort/">seclists.org</a> are great source of information, as were some of the papers at the <a href="https://uk.sans.org/reading-room/whitepapers/tools/">SANS UK Reading Room</a> site.</p>
<p>In Part 2 of this post, I&#8217;ll be tackling the business of implementing the main processing method within the preprocessor, which will require devising an algorithm which can detect the tell-tale signs of a buffer overflow attack, without relying rigidly on the details of any specific vulnerability or known attack strategy.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Throwing Star LAN Tap</title>
		<link>./../../../throwing-star-lan-tap/index.html</link>
		
		<dc:creator><![CDATA[spen440]]></dc:creator>
		<pubDate>Wed, 02 Aug 2017 17:50:05 +0000</pubDate>
				<category><![CDATA[Network Reconnaissance]]></category>
		<category><![CDATA[Ethernet]]></category>
		<category><![CDATA[Network]]></category>
		<category><![CDATA[Packet Capture]]></category>
		<category><![CDATA[Wireshark]]></category>
		<guid isPermaLink="false">./../../../index.html?p=209</guid>

					<description><![CDATA[Just recently I decided to add a passive LAN tap to my toolkit, partly because I needed a quick, easy and non-intrusive way of being able to monitor network traffic, and partly to justify buying a new soldering iron. The kit was manufactured by Great Scott Gadgets to Michael Ossman&#8217;s original design and supplied by RoboSavvy. [&#8230;]]]></description>
										<content:encoded><![CDATA[<h2></h2>
<p>Just recently I decided to add a passive LAN tap to my toolkit, partly because I needed a quick, easy and non-intrusive way of being able to monitor network traffic, and partly to justify buying a new soldering iron.</p>
<p><span id="more-209"></span></p>
<p>The kit was manufactured by <a href="https://greatscottgadgets.com/">Great Scott Gadgets</a> to <a href="http://ossmann.blogspot.co.uk/2011/02/throwing-star-lan-tap.html">Michael Ossman&#8217;s</a> original design and supplied by <a href="https://robosavvy.com/web/">RoboSavvy</a>. It&#8217;s been a while since I tackled anything involving a PCB and molten metal, but the lack of dry and/or bridged joints must mean I haven&#8217;t completely lost the ability to solder just yet.</p>
<figure id="attachment_212" aria-describedby="caption-attachment-212" style="width: 376px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/t-star-lan-tap.jpeg"><img loading="lazy" decoding="async" class="wp-image-212" src="./../../../wp-content/uploads/2017/08/t-star-lan-tap-300x232.jpeg" alt="" width="376" height="291" data-wp-pid="212" srcset="./../../../wp-content/uploads/2017/08/t-star-lan-tap-300x232.jpeg 300w, ./../../../wp-content/uploads/2017/08/t-star-lan-tap-210x163.jpeg 210w, ./../../../wp-content/uploads/2017/08/t-star-lan-tap.jpeg 431w" sizes="(max-width: 376px) 100vw, 376px" /></a><figcaption id="caption-attachment-212" class="wp-caption-text">Kit contents</figcaption></figure>
<figure id="attachment_26" aria-describedby="caption-attachment-26" style="width: 376px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427.jpg"><img loading="lazy" decoding="async" class="wp-image-26" src="./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427-240x300.jpg" alt="" width="376" height="470" data-wp-pid="26" srcset="./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427-240x300.jpg 240w, ./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427-820x1024.jpg 820w, ./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427-768x959.jpg 768w, ./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427-168x210.jpg 168w, ./../../../wp-content/uploads/2017/05/WP_20170518_17_46_44_Pro-e1495127160427.jpg 841w" sizes="(max-width: 376px) 100vw, 376px" /></a><figcaption id="caption-attachment-26" class="wp-caption-text">Fully assembled</figcaption></figure>
<p>There are four RJ-45 ports &#8211; two for connecting in-line on the Ethernet network to be monitored, and two monitoring ports. As an unpowered tap, it doesn&#8217;t have the ability to cope with full duplex Gigabit Ethernet, so only two of transmit/receive pairs are broken out to monitor ports. This also means that the monitoring ports are unidirectional; to sniff traffic in both directions at the same time you&#8217;d need to connect both monitoring ports, for example using a dual port NIC.</p>
<p>The on board capacitors are there to act as low-pass filters, forcing the network devices at either end of the network segment being monitored to fall back to 100BASE-T, allowing Gigabit traffic 1000BASE-T to at least be monitored, albeit over a link downgraded to Fast Ethernet (of course, if you only ever want to sniff 100BASE-T traffic, none of that matters anyway).</p>
<p>As a quick test just to prove things work as expected, I inserted the tap between my Mac and a switch on my home network, then kicked off an aggressive Nmap scan against my wife&#8217;s poor unsuspecting Roberts &#8220;smart&#8221; radio. Running Wireshark on a laptop connected to the upstream monitoring port, we can see the scan activity being directed at the target device; the capture in the screenshot shows an attempt by Nmap to locate signs of unprotected Git repositories at the root of the web admin interface, by using the http-gti.nse script as part of the aggressive scan:</p>
<p><a href="./../../../wp-content/uploads/2017/08/WP_20170801_17_20_39_Rich_LI-2.png"><img loading="lazy" decoding="async" class=" wp-image-278 aligncenter" src="./../../../wp-content/uploads/2017/08/WP_20170801_17_20_39_Rich_LI-2-169x300.png" alt="" width="231" height="410" srcset="./../../../wp-content/uploads/2017/08/WP_20170801_17_20_39_Rich_LI-2-169x300.png 169w, ./../../../wp-content/uploads/2017/08/WP_20170801_17_20_39_Rich_LI-2-118x210.png 118w, ./../../../wp-content/uploads/2017/08/WP_20170801_17_20_39_Rich_LI-2.png 577w" sizes="(max-width: 231px) 100vw, 231px" /></a></p>
<figure id="attachment_215" aria-describedby="caption-attachment-215" style="width: 660px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/lan-tap-nmap.png"><img loading="lazy" decoding="async" class="wp-image-215" src="./../../../wp-content/uploads/2017/08/lan-tap-nmap-300x150.png" alt="" width="660" height="330" data-wp-pid="215" srcset="./../../../wp-content/uploads/2017/08/lan-tap-nmap-300x150.png 300w, ./../../../wp-content/uploads/2017/08/lan-tap-nmap-768x384.png 768w, ./../../../wp-content/uploads/2017/08/lan-tap-nmap-210x105.png 210w, ./../../../wp-content/uploads/2017/08/lan-tap-nmap.png 818w" sizes="(max-width: 660px) 100vw, 660px" /></a><figcaption id="caption-attachment-215" class="wp-caption-text">Nmap scan</figcaption></figure>
<figure id="attachment_206" aria-describedby="caption-attachment-206" style="width: 661px" class="wp-caption aligncenter"><a href="./../../../wp-content/uploads/2017/08/lan-tap-cap.png"><img loading="lazy" decoding="async" class="wp-image-206" src="./../../../wp-content/uploads/2017/08/lan-tap-cap-300x169.png" alt="" width="661" height="372" data-wp-pid="206" srcset="./../../../wp-content/uploads/2017/08/lan-tap-cap-300x169.png 300w, ./../../../wp-content/uploads/2017/08/lan-tap-cap-1024x576.png 1024w, ./../../../wp-content/uploads/2017/08/lan-tap-cap-768x432.png 768w, ./../../../wp-content/uploads/2017/08/lan-tap-cap-210x118.png 210w, ./../../../wp-content/uploads/2017/08/lan-tap-cap.png 1366w" sizes="(max-width: 661px) 100vw, 661px" /></a><figcaption id="caption-attachment-206" class="wp-caption-text">Packet analysis with Wireshark</figcaption></figure>
<p>Given that it&#8217;s highly portable, easy to use and invisible to network scans, I suspect this little gadget will be getting plenty of use in the field in the near future.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
